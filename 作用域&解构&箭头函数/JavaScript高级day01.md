## 一、作用域

了解作用域队程序执行的影响及作用域链的查找机制，使用闭包函数创建隔离作用域避免全局变量污染

### 局部作用域

#### 函数作用域：

在函数内部声明的变量只能在函数内部被访问，外部无法直接访问

```javascript
function getSum() {
    //函数内部是函数作用域	属于局部变量
    const num = 10
}
console.log(num)	//此处报错，函数外部不能使用局部作用域变量
```

>总结：
>
>1.函数内部声明的变量，在函数外部无法被访问
>
>2.函数的参数也是函数内部的局部变量
>
>3.不同函数内部声明的变量无法相互访问
>
>4.函数执行完毕后，函数内部的变量实际被清空了

#### 块作用域：

在JavaScript中使用{}包裹的代码称为代码块，代码块内部声明的变量外部将***有可能***无法被访问

```javascript
for (let t = 1; t <= 6; t++) {
    // t 只能在该代码块中被访问
    console.log(t)	//正常
}
//超出了t的作用域
console.log(t)	//报错
```

>总结：
>
>1.let声明的变量会产生块作用域，var不会产生块作用域
>
>2.const声明的常量也会产生块作用域
>
>3.不同代码块之间的变量无法互相访问
>
>4.推荐使用let或const

### 全局作用域

 <script>标签和.js文件的最外层就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问，全局作用域中声明的变量，任何其他作用域都可以被访问

```javascript
//全局作用域下声明num变量
const num = 10
function fn() {
    //函数内部可以使用全局作用域的变量
    console.log(num)
}
```

>注意：
>
>1.为Window对象动态添加的属性默认也是全局的，不推荐！
>
>2.函数中未使用任何关键字声明的变量为全局变量，不推荐！！
>
>3.尽可能少的声明全局变量，防止全局变量被污染

### 作用域链

作用域链本质上是底层的变量查找机制

在函数被执行时，会优先查找当前函数作用域中查找变量

如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域

>总结：
>
>1.嵌套关系的作用域串联起来形成了作用域链
>
>2.相同作用域链中按着从小到大的规则查找变量
>
>3.子作用域能够访问父作用域，父级作用域无法访问子级作用域

### JS垃圾回收机制

JS中内存你的分配和回收都是自动完成的，内存你在不使用的时候会被垃圾回收器自动回收

#### 内存泄露

不再用到的内存，没有及时释放，就叫做内存泄露

#### 内存的生命周期

JS环境中分配的内存，一般有如下生命周期：

1.内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存

2.内存使用：即读写内存，也就是使用变量、函数等

3.内存回收：使用完毕，由垃圾回收自动回收不再使用的内存

>注意：
>
>1.全局变量一般不会回收（关闭页面回收）
>
>2.一般情况下局部变量的值，不用了，会被自动回收掉

#### 引用技术法：

IE采用的引用计数算法，定义“内存不再使用”的标签很简单，就是看一个对象是否有指向它的引用

算法：

1.跟踪记录每个值被引用的次数

2.如果这个值的被引用了一次，那么就记录次数1

3.多次引用会累加

4.如果减少一个引用就减1 

5.如果引用次数是0，则释放内存

>缺陷：
>
>嵌套引用，如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露

#### 标记清楚法：

### 闭包

### 变量提升

## 二、函数进阶

## 三、解构赋值